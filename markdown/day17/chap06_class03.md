2023년 2월 4일 토요일

---

## chap.06 class03

### 1. 패키지(package)

- 클래스를 체계적으로 관리하기 위해서 폴더를 만들어 저장하듯이 패키지를 만들어 클래스를 저장 및 관리한다.
- 패키지의 물리적인 형태는 파일 시스템의 폴더이다.
- 형식 : `상위패키지.하위패키지.클래스`
- 패키지 선언 : `package name1.name2.name3;`
- 패키지는 클래스를 컴파일하는 과정에서 자동적으로 생성되는 폴더이다.
- 컴파일러는 클래스에 포함되어 있는 패키지 선언을 보고 파일 시스템의 폴더로 자동 생성시킨다.
- 선언 규칙

  - 숫자로 시작해서는 안되고, \_,$를 제외한 특수 문자를 사용해서는 안된다.
  - java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안된다.
  - 소문자로만 작성하는 것이 관례이다.

    `package javaMid6.ex02;`

- import : 다른 패키지에 있는 클래스를 사용할 경우 import를 사용하여 명시한다.

  `import java.util.Scanner;`

  - Scanner 클래스를 해당 클래스에 사용한다.
  - util 패키지에 모든 클래스를 사용하고 싶다면 .\*을 하면 된다.
  - 여러 패키지를 import 하고 싶다면 그때마다 각각의 package를 import 선언해야한다.
  - 선언한 각 import문 속에 객체화할 동일한 클래스가 존재한다면 컴파일 에러를 발생시킨다.

### 2. 접근 제한자

| 접근제한  |           적용대상           |            접근할 수 없는 클래스             |
| :-------: | :--------------------------: | :------------------------------------------: |
|  public   | 클래스, 필드, 생성자, 메소드 |                     없음                     |
| protected |     필드, 생성자, 메소드     | 자식클래스가 아닌 다른패키지에 소속된 클래스 |
|  default  | 클래스, 필드, 생성자, 메소드 |         다른 패키지에 소속된 클래스          |
|  private  |     필드, 생성자, 메소드     |               모든 외부 클래스               |

### 3. 접근 제어자를 이용한 캡슐화

1. 접근 제어자를 사용하는 이유

   - 외부로부터 데이터를 보호하기 위해서
   - 외부에서는 불필요한 내부적으로만 사용되는 부분을 감추기 위해서

2. 생성자의 접근제어자

   - 생성자에 접근 제어자를 사용함으로서 인스턴스의 생성을 제한 할 수 있다.
   - 보통 생성자의 접근제어자는 클래스의 접근 제어자와 같지만 다르게 지정할 수도 있다.
   - 생성자의 접근제어자를 private로 지정하면 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.
   - 싱글톤 타입형태로 이용한다.

### 4. 제어자의 조합

1. 메소드에 static과 abstract를 함께 사용할 수 없다.

   - static 메소드는 몸통이 있는 메소드에만 사용할 수 있다.

2. 클래스에 abstract와 final을 동시에 사용할 수 없다.

   - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속(implements)을 통해서 완성되어야 한다는 의미로 서로 모순된다.

3. abstract 메소드의 접근제어자가 private일 수 없다.

   - abstract 메소드는 자식 클래스에서 구현해주어야 하는데 접근제어자가 private이면 자식클래스에서 접근할 수 없다.

4. 메소드에 private과 final을 같이 사용할 필요는 없다.

   - 접근제어자가 private인 메소드는 오버라이딩 할 수 없다.

### 5.getter, setter 메소드

- 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨어질 수 있기 때문에, 일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.
- 객체지향 프로그래밍에서는 메소드를 통해서 데이터를 변경하는 방법을 선호한다.
- 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서, 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.

6. 싱글톤

- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있는데, 이 객체를 싱글톤이라고 한다.
- 클래스 외부에서 `new` 연산자로 생성자를 호출 할 수 없도록 막아야 하는데, 생성자에 private 접근제한자를 붙여서 호출할 수 없도록 한다.
- 클래스 자신의 타입으로 정적 필드를 하나 선언하고, 자신의 객체를 생성해 초기화한다.
- 클래스 내부에서는 `new` 연산자로 생성자 호출이 가능하고, 정적 필드도 private 접근제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다.
- 대신 외부에서 호출할 수 있는 정적메소드 `getInstance()`를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

```java
package tempMemo;

public class A {

	private static A a = new A();	// 클래스 자신의 타입으로 private 필드를 선언

	private A() {
//		private 선언된 class A의 생성자. 외부에서 객체생성 할 수 없다.
	}

	public static A getInstance() {
		return a;	// 자신의 주소를 리턴. 외부에서 메소드만 호출해간다. 메모리 효율성 증대
	}
}

package tempMemo;

public class Main {
	public static void main(String[] args) {
//		A a = new A(); 		// private 생성자로 인해 객체생성 불가.
		A.getInstance(); // 메소드로 접근한다.
							// static method 로 자신을 객체생성 했을 때에 메모리에 바로 올라간다.
	}
}
```
