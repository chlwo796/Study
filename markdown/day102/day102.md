2023년 6월 5일 월요일

---

## day 102

### memo

- `K-MOOC` : 자료구조, 알고리즘(코딩테스트)
- [JOIN쿼리 참고](https://dlgkstjq623.tistory.com/297)

### 네트워크

- 클라우드 컴퓨팅 서비스

  - IaaS(Infrastructure as a Service)
    - 필요한 구성 요소만 구매하고 필요에 따라 확장 또는 축소할 수 있는 유연성을 제공
    - 간접비가 낮고 유지관리 비용이 들지 않음
    - 개발 및 테스트 환경의 구축 및 제거가 빠르고 유연
    - AWS, Microsoft Anure, Google Gloude
  - PaaS(Platforms as a Service)
    - 제공업체가 자체 인프라에서 하드웨어와 소프트웨어를 호스팅하고 이러한 플랫폼을 사용자에게 통합 솔루션, 솔루션 스택 또는 인터넷을 통한 서비스로 제공
  - SaaS(Software as a Service)
    - 모든 어플리케이션은 제공업체가 관리하며 웹 브라우저를 통해 제공
    - 제공업체가 소프트웨어 업데이트, 버그 수정 및 기타 일반 소프트웨어 유지관리 작업을 처리
    - 사용자는 대시보드 또는 API를 통해 어플리케이션에 연결
    - Dropbox, Google Apps

- 온프레미스(On-premise)

### 비용 산정 기법

- LOC(원시 코드 라인 수) 기법
  - 산정공식
    - 노력(=인월=MM) = 개발기간 \* 투입인원 = LOC/1인당 월평균 생산 코드 라인 수
    - 개발비용 = 노력 \* 단위 비용(=1인당 월 평균 인건비)
    - 개발 기간 = 노력 / 투입 인원
    - 생산성 = LOC/노력

### 알고리즘

- 알고리즘의 분석 : 정확성 분석 + 효율성 분석
- 알고리즘의 효율성 분석

  - 공간 복잡도 : 메모리 양
  - 시간 복잡도 : 수행 시간

- 알고리즘 표기법 : Big-oh O, Big-omega, Big-theta
- 정렬 알고리즘
  - 선택 정렬 : 큰(작) 키 값을 찾아 교환, 주어진 데이터 중에서 가장 작은 값부터 차례대로 '선택'해서 나열하는 방식(O(n^2))
  - 버블 정렬 : 모든 인접한 두 값을 비교하여 왼쪽의 값이 더 큰 경우에는 자리를 바꾸는 과정을 반복해서 정렬하는 방식
  - 삽입 정렬 : 주어진 데이터를 하나씩 뽑은 후, 나열된 데이터들이 항상 정렬된 형태를 갖도록 뽑은 데이터를 바른 위치에 '삽입'해서 나열하는 방식
  - 입력 배열을 정렬부분과 미정렬 부분으로 구분해서 미정렬 부분에서 첫 번째 데이터를 뽑은 후 정렬 부분에서 제자리를 찾아 뽑은 데이터를 삽입하는 과정을 반복
  - 쉘정렬 : 삽입 정렬의 단점 보완
    - 데이터가 삽입될 위치에서 멀리 떨어져 있어도 바로 왼쪽의 이웃한 데이터와의 비교를 통해 한 번에 한 자리씩만 이동
  - 힙정렬 : 완전 이진 트리
    - 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같으며 임의의 값 삽입과 최대값 삭제가 쉽다.

### java

- insertion sort

  ```java
  package exam6;

  import java.util.Arrays;

  public class InsertionSort {
    public static void main(String[] args) {
      // inArr = {96, 70, 85, 20, 63, 30};
      // 96       70, 85, 20, 65, 30

      int[] inArr = {96, 70, 85, 20, 65, 30};
      int i = 0; // 밖 for, 정렬안된 곳
      int j = 0; // 안 for, 정렬된 곳
      int key = 0; // key값, 정렬될 부분의 자료들과 비교할 값(정렬 안된 부분의 첫번째 요소값)

      for(i = 1;i<inArr.length;i++) { // 정렬 안된 곳
        key = inArr[i];
        for(j=i-1;j>=0;j--) { // 정렬 된 곳
          // key 값이 정렬된 부분의 값들과 비교(판단, if문) 해서 더 작은가? 작으면 자리바꿈, 크면 삽입
          if(inArr[j]<=key) { // 비교해서 정렬 안된 부분의 비교값이 key보다 작으면 더 이상 비교가 필요 없음
            break; // 비교 멈춤
          }
          inArr[j+1] = inArr[j]; // key가 정렬된 부분의 비교 값보다 작으면 자리교환
        } // end 내부 for
        inArr[j+1] = key; // 1번 위치, key 값이 비교대상 값보다 크므로 비교대상 뒤쪽에 위치시키면 됨
      }
      System.out.println(Arrays.toString(inArr));
    }
  }
  ```
